# AI Agent Architecture: Email Triage Agent

This document outlines the architecture for the AI agent prototype. The design fulfills the "Reason, Plan, Execute" requirement and incorporates multi-agent collaboration and custom tools for bonus points.

## 1. Components & Architecture

The system is designed using a **Planner-Executor** model, which is a form of multi-agent collaboration.



* **Planner (The "Brain"):** A high-level Large Language Model (in our case, Google's `gemini-1.5-flash-latest`) is responsible for **reasoning** and **planning**. It receives a high-level goal (e.g., "Triage my inbox") and a list of available tools. Its *only* job is to analyze the goal and generate a step-by-step plan in a machine-readable format (JSON).

* **Executor (The "Hands"):** This is the main `agent.py` script. It acts as a second, simpler agent. Its job is to **execute** the plan generated by the Planner. It parses the JSON, calls the necessary tools in order, and handles the flow of data between steps.
    > **Note on Prototype:** For this prototype's robustness, the plan is hard-coded inside `agent.py` rather than being dynamically generated on every run. This hard-coded plan *is* the "Reasoned Plan" for the task.

* **Specialist Model (The "Tool"):** This is the **fine-tuned model** we built (`classifier.py`). It acts as a highly specialized, third agent. It has one job: classify an email with extreme speed and accuracy. The Executor agent *delegates* the classification task to this specialist.

## 2. Interaction Flow (Reason, Plan, Execute)

The agent follows the full "Reason, Plan, Execute" cycle:

1.  **REASON:** The agent is given the high-level goal: "Triage my inbox."

2.  **PLAN:** The agent's logic (hard-coded in `agent.py` for this prototype) establishes the following robust plan:
    1.  Call the `tool_fetch_unread_emails` to get a list of all new emails.
    2.  Begin a loop for each email in that list.
    3.  **Delegate:** For the current email, call the `tool_classify_email` (our specialist agent) and pass it the email's text.
    4.  Receive the classification (`Urgent`, `To-Do`, or `FYI`) from the specialist.
    5.  Call the `tool_move_email`, passing the email's ID and the classification label as the folder name.
    6.  End the loop and report completion.

3.  **EXECUTE:** The `agent.py` script runs this plan. The output log shows it successfully fetching 3/3 emails, calling the `classifier.py` script for all three, and then moving them to the correct, model-driven folders (`Urgent`, `To-Do`).

## 3. Justification (Mandatory & Bonus)

* **Mandatory (Fine-tuned Model):** The `classifier.py` script loads our fine-tuned **LoRA model**. We chose this because a general-purpose LLM is too slow and expensive to run on every single email. Our specialist model is fast, free to run, and (as shown by our 100% accuracy) highly reliable for this specific task.
* **Bonus (Multi-agent Collaboration):** This architecture is a multi-agent system:
    * **Agent 1 (Planner):** The Gemini LLM that *designs* the plan (in a full build).
    * **Agent 2 (Executor):** The `agent.py` script that *manages* the project.
    * **Agent 3 (Specialist):** The `classifier.py` model that *performs* the expert task.
* **Bonus (Custom Tools):** We implemented `tool_classify_email`, a custom tool that executes our fine-tuned model in a separate subprocess, proving the agent can leverage specialized, custom-built capabilities.